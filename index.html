<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
  <style>
    body {
        margin: 0;
        background: radial-gradient(circle, #2b0a1a 0%, #05050a 100%);
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
    }
    canvas { 
        display: block; 
        filter: drop-shadow(0 0 20px rgba(230, 166, 184, 0.3)); 
    }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = 500;
canvas.height = 900;

const W = canvas.width;
const H = canvas.height;

const BASE_Y = 800;
const CENTER_X = W / 2;

let lastTime = 0;

const COLORS = {
    purple: { main: "#b388ff", light: "#ede7f6", dark: "#7c4dff" },
    pink: { main: "#ff80ab", light: "#fce4ec", dark: "#f50057" },
    yellow: { main: "#ffd740", light: "#fff9c4", dark: "#ffab00" },
    stem: "#2d5a27",
    wrap: "#d81b60",
    wrapLight: "#f48fb1",
    ribbon: "#ffeb3b"
};

class Tulip {
    constructor(x, height, color) {
        this.x = x;
        this.height = height;
        this.currHeight = 0;
        this.bloom = 0;
        this.color = color;
        this.offset = Math.random() * Math.PI * 2;
    }

    update(delta) {
        if (this.currHeight < this.height) {
            this.currHeight += 200 * delta;
        } else if (this.bloom < 1) {
            this.bloom += 1 * delta;
        }
    }

    draw(time) {
        const sway = Math.sin(time * 0.002 + this.offset) * 4;
        const topX = this.x + sway;
        const topY = BASE_Y - this.currHeight;

        // Stem
        ctx.beginPath();
        ctx.moveTo(this.x, BASE_Y);
        ctx.quadraticCurveTo(this.x + sway/2, BASE_Y - this.currHeight/2, topX, topY);
        ctx.strokeStyle = COLORS.stem;
        ctx.lineWidth = 3;
        ctx.stroke();

        if (this.bloom > 0) {
    ctx.save();
    ctx.translate(topX, topY);
    ctx.scale(this.bloom, this.bloom);

    const drawPetal = (angle, scaleX, scaleY, fill) => {
        ctx.save();
        ctx.rotate(angle);
        ctx.scale(scaleX, scaleY);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(-10, -10, -15, -40, 0, -50);  // left curve
        ctx.bezierCurveTo(15, -40, 10, -10, 0, 0);       // right curve
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.restore();
    };
          const petals = [
        {angle: 0, color: this.color.main},
        {angle: Math.PI / 6, color: this.color.main},
        {angle: -Math.PI / 6, color: this.color.main},
        {angle: Math.PI / 3, color: this.color.dark},
        {angle: -Math.PI / 3, color: this.color.dark},
        {angle: 0, color: this.color.light, scaleX: 0.9, scaleY: 1} // top inner petal
    ];

            petals.forEach(p => drawPetal(p.angle, p.scaleX || 1, p.scaleY || 1, p.color));
    ctx.restore();
        }
    }
}

const tulips = [];

function init() {
    const palette = [COLORS.purple, COLORS.yellow];

    for (let i = 0; i < 30; i++) {  // reduced from 28 â†’ 20
        const spread = 210;
        const x = CENTER_X + (Math.random() - 0.5) * spread;
        const height = 150 + Math.random() * 100;
        const color = palette[Math.floor(Math.random() * palette.length)];
        tulips.push(new Tulip(x, height, color));
    }
}

function drawWrap() {
    ctx.fillStyle = COLORS.wrap;
    ctx.beginPath();
    ctx.moveTo(CENTER_X - 180, BASE_Y - 300);
    ctx.bezierCurveTo(CENTER_X - 120, BASE_Y - 350, CENTER_X + 120, BASE_Y - 350, CENTER_X + 180, BASE_Y - 300);
    ctx.lineTo(CENTER_X + 60, BASE_Y + 50);
    ctx.bezierCurveTo(CENTER_X + 20, BASE_Y + 70, CENTER_X - 20, BASE_Y + 70, CENTER_X - 60, BASE_Y + 50);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = COLORS.wrapLight;
    ctx.beginPath();
    ctx.moveTo(CENTER_X - 150, BASE_Y - 260);
    ctx.bezierCurveTo(CENTER_X - 100, BASE_Y - 300, CENTER_X + 100, BASE_Y - 300, CENTER_X + 150, BASE_Y - 260);
    ctx.lineTo(CENTER_X + 40, BASE_Y + 50);
    ctx.bezierCurveTo(CENTER_X + 20, BASE_Y + 65, CENTER_X - 20, BASE_Y + 65, CENTER_X - 40, BASE_Y + 50);
    ctx.closePath();
    ctx.fill();
}

function drawFrontWrap() {
    ctx.fillStyle = COLORS.wrap;
    ctx.beginPath();
    ctx.moveTo(CENTER_X - 160, BASE_Y - 100);
    ctx.bezierCurveTo(CENTER_X - 80, BASE_Y - 150, CENTER_X + 80, BASE_Y - 150, CENTER_X + 160, BASE_Y - 100);
    ctx.lineTo(CENTER_X + 80, BASE_Y + 50);
    ctx.bezierCurveTo(CENTER_X + 40, BASE_Y + 70, CENTER_X - 40, BASE_Y + 70, CENTER_X - 80, BASE_Y + 50);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = COLORS.ribbon;
    ctx.fillRect(CENTER_X - 85, BASE_Y - 20, 170, 15);
}

function animate(timestamp) {
    const delta = (timestamp - lastTime) / 2000;
    lastTime = timestamp;

    ctx.clearRect(0, 0, W, H);

    drawWrap();

    tulips.forEach(t => {
        t.update(delta);
        t.draw(timestamp);
    });

    drawFrontWrap();

    requestAnimationFrame(animate);
}

init();
requestAnimationFrame(animate);
</script>
</body>
</html>